pointdown <- data[wheredown,];coefdown <- Coef[wheredown,]
angleminlist <- rbind(c(anglemin,tan2),pointup,pointdown,coefup,coefdown)
angleequallist <- angleminlist;anglemeanlist <- angleminlist;angleneighlist <- angleminlist;anglemedianlist <- angleminlist
}else{
updownanglevs <- comple(outnum,Angle,orderup,orderdown)
updown <- updownanglevs[[1]]
anglevs <- updownanglevs[[2]]
where <- order(anglevs)[1]
whereup <- updown[where,1]
wheredown <- updown[where,2]
anglemin <- anglevs[where]
tanup <- Tan[whereup];tandown <- Tan[wheredown]
tan2 <- (tanup-tandown)/(1+tanup*tandown)
pointup <- data[whereup,];coefup <- Coef[whereup,]
pointdown <- data[wheredown,];coefdown <- Coef[wheredown,]
angleminlist <- rbind(c(anglemin,tan2),pointup,pointdown,coefup,coefdown)
if(outnum==1){
angleequallist <- angleminlist
}else if(outnum%%2==0){
where <- ceiling(outnum/2)
whereup <- updown[where,1]
wheredown <- updown[where,2]
angleequal <- anglevs[where]
tanup <- Tan[whereup];tandown <- Tan[wheredown]
tan2 <- (tanup-tandown)/(1+tanup*tandown)
pointup <- data[whereup,];coefup <- Coef[whereup,]
pointdown <- data[wheredown,];coefdown <- Coef[wheredown,]
angleequallist <- rbind(c(angleequal,tan2),pointup,pointdown,coefup,coefdown)
}else{
where <- floor(outnum/2)
whereup <- updown[where,1];whereupup <- updown[where+1,1]
wheredown <- updown[where,2];wheredowndown <- updown[where+1,2]
pointup <- apply(data[c(whereup,whereupup),],2,mean);coefup <- ab(pointup,start)
pointdown <- apply(data[c(wheredown,wheredowndown),],2,mean);coefdown <- ab(pointdown,start)
angleequal <- abs(mean(Angle[c(whereup,whereupup)])-mean(Angle[c(wheredown,wheredowndown)]));tan2 <- tan(angleequal)
angleequallist <- rbind(c(angleequal,tan2),pointup,pointdown,coefup,coefdown)
}
anglemean <- mean(anglevs);tan2 <- tan(anglemean)
pointup <- apply(data[updown[,1],],2,mean);coefup <- ab(pointup,start)
pointdown <- apply(data[updown[,2],],2,mean);coefdown <- ab(pointdown,start)
anglemeanlist <- rbind(c(anglemean,tan2),pointup,pointdown,coefup,coefdown)
anglemedian <- median(anglevs);tan2 <- tan(anglemedian)
pointup <- apply(data[updown[,1],],2,median);coefup <- ab(pointup,start)
pointdown <- apply(data[updown[,2],],2,median);coefdown <- ab(pointdown,start)
anglemedianlist <- rbind(c(anglemedian,tan2),pointup,pointdown,coefup,coefdown)
where <- order(anglevs)[1]
whereup <- updown[where,1];upnum <- which(orderup==whereup);whereupup <- orderup[ifelse(upnum==1,upnum,upnum-1)]
wheredown <- updown[where,2];downnum <- which(orderdown==wheredown);wheredowndown <- orderdown[ifelse(downnum==1,downnum,downnum-1)]
pointup <- apply(data[c(whereup,whereupup),],2,mean);coefup <- ab(pointup,start)
pointdown <- apply(data[c(wheredown,wheredowndown),],2,mean);coefdown <- ab(pointdown,start)
angleneigh <- abs(mean(Angle[c(whereup,whereupup)])-mean(Angle[c(wheredown,wheredowndown)]));tan2 <- tan(angleneigh)
angleneighlist <- rbind(c(angleneigh,tan2),pointup,pointdown,coefup,coefdown)
}
out <- list(anglemin=angleminlist,anglemedian=anglemedianlist,angleequal=angleequallist,anglemean=anglemeanlist,angleneigh=angleneighlist)
return(out)
}
sigmamatrix <- function(sigma,rho,i){
Sigma <- matrix(c(sigma[1],rho*(1-(i-1)/5)*sqrt(sigma[1]*sigma[2]),rho*(1-(i-1)/5)*sqrt(sigma[1]*sigma[2]),sigma[2]),2,2)
return(Sigma)
}
split <- function(mu,sigma,rho,i,N,Tij){
data <- mvrnorm(Tij*N^i,mu,sigmamatrix(sigma,rho,i))
return(data)
}
treedataresidual <- function(mu,sigma,rho,T,N,Tij){
treeresidual1 <- vector('list',T)
treeresidual2 <- vector('list',T)
for(i in 1:T){
residual1 <- split(mu,sigma,rho,i,N,Tij)
treeresidual1[[i]] <- residual1[,1]
treeresidual2[[i]] <- residual1[,2]
}
return(treeresidualdata=list(treeresidual1=treeresidual1,treeresidual2=treeresidual2))
}
musigma <- function(data){
mu <- apply(data,2,mean)
sigma <- matrix(rep(0,(length(mu))^2),length(mu),length(mu))
for(i in 1:(dim(data)[1])){
x0 <- matrix(data[i,]-mu,length(mu),1)
sigma <- sigma+(x0)%*%t(x0)
}
sigma <- sigma/(dim(data)[1])
return(c(mu,diag(sigma),sigma[1,2]/sqrt(sigma[1,1]*sigma[2,2])))
}
datauni <- function(data){
T<- length(data[[1]])
Sigma <- sqrt(musigma(cbind(data[[1]][[T]],data[[2]][[T]]))[3:4])
for(i in 1:T){
data[[1]][[i]] <- data[[1]][[i]]/Sigma[1]*sqrt(0.0001)
data[[2]][[i]] <- data[[2]][[i]]/Sigma[2]*sqrt(0.0001)
data[[1]][[i]] <- data[[1]][[i]]-mean(data[[1]][[i]])+sqrt(-2*log(0.05)*0.0001 + sum(1/(1:i))*0.1)
data[[2]][[i]] <- data[[2]][[i]]-mean(data[[2]][[i]])+sqrt(-2*log(0.05)*0.0001 + sum(1/(1:i))*0.1)
}
data <- cbind(unlist(data[[1]]),unlist(data[[2]]))
return(data)
}
deltaanglefunc <- function(rho,mu,sigma,T,N,Tij,alpha,start){
data <- treedataresidual(mu,sigma,rho,T,N,Tij)
data <- list(without=cbind(unlist(data[[1]]),unlist(data[[2]])),with=datauni(data))
deltaangle <- c()
for(i in 1:2){
out <- anglealpha(data[[i]],alpha,start)
deltaangle <- rbind(deltaangle,unlist(lapply(out,function(out0){return(out0[1,1])})))
}
return(deltaangle)
}
largefunc <- function(rho1,rho2,mu,sigma,T,N,Tij,n2,alpha,start){
deltaangle1 <- vector('list',2)
deltaangle2 <- vector('list',2)
for(i in 1:n2){
deltaangle10 <- deltaanglefunc(rho1,mu[1:2],sigma[1:2],T,N,Tij,alpha,start)
deltaangle20 <- deltaanglefunc(rho2,mu[3:4],sigma[3:4],T,N,Tij,alpha,start)
for(j in 1:2){
deltaangle1[[j]] <- rbind(deltaangle1[[j]],deltaangle10[j,])
deltaangle2[[j]] <- rbind(deltaangle2[[j]],deltaangle20[j,])
}
}
out <- c()
for(j in 1:2){out <- rbind(out,unlist(lapply(1:5,function(i){return(sum(deltaangle1[[j]][,i]>=deltaangle2[[j]][,i])/n2)})))}
return(out)
}
rho12func <- function(rho1,rho2,T,N,Tij,n1,n2,alpha,start){
out <- vector('list',2)
for(i in 1:n1){
sigma <- round(1/rgamma(4,50,100),2)/100
mu <- sqrt((sigma)*6) + 0.01 + c(1,1,0,0)
out0 <- largefunc(rho1,rho2,mu,sigma,T,N,Tij,n2,alpha,start)
for(j in 1:2){out[[j]] <- rbind(out[[j]],out0[j,])}
}
return(out)
}
data1 <- treedataresidual(mu, sigma, rho1, T, N, Tij)
data1 <- treedataresidual(mu, sigma, rho1, T, N, Tij)
data1 <- treedataresidual(mu, sigma, rho1, depth = 6, N, Tij)
data1 <- treedataresidual(mu, sigma, rho1, T = 6, N, Tij)
# 首先定义所有必要的变量
mu <- c(1, 1, 0, 0)  # 均值向量
sigma <- c(0.5, 0.5, 0.5, 0.5)  # 方差向量
rho1 <- 0.3  # 第一个相关系数
rho2 <- 0.7  # 第二个相关系数
T_val <- 6   # 深度参数（避免使用T，因为T是TRUE的缩写）
N <- 2       # 分支因子
Tij <- 1     # 时间参数
# 现在可以调用函数了
data1 <- treedataresidual(mu, sigma, rho1, T_val, N, Tij)
data2 <- treedataresidual(mu, sigma, rho2, T_val, N, Tij)
# 使用2维的mu和sigma
mu <- c(0, 0)  # 2维均值向量
sigma <- c(1, 1)  # 2维方差向量
rho1 <- 0.3
rho2 <- 0.7
T_val <- 6
N <- 2
Tij <- 1
data1 <- treedataresidual(mu, sigma, rho1, T_val, N, Tij)
data2 <- treedataresidual(mu, sigma, rho2, T_val, N, Tij)
result1 <- anglealpha(data1, alpha, start)
result1 <- anglealpha(data1)
data1
anglealpha[1]
anglealpha(data1)
# 定义参数
mu_2d <- c(0, 0)        # 2维均值向量
sigma_2d <- c(1, 1)     # 2维方差向量
rho1 <- 0.3
rho2 <- 0.7
T_val <- 6
N <- 2
Tij <- 1
alpha <- 0.05           # 1 - coverage
start <- c(0, 0)
# 生成数据
data1 <- treedataresidual(mu_2d, sigma_2d, rho1, T_val, N, Tij)
data2 <- treedataresidual(mu_2d, sigma_2d, rho2, T_val, N, Tij)
# 转换为矩阵格式
data1_matrix <- cbind(unlist(data1[[1]]), unlist(data1[[2]]))
data2_matrix <- cbind(unlist(data2[[1]]), unlist(data2[[2]]))
# 计算角度
result1 <- anglealpha(data1_matrix, alpha, start)
result2 <- anglealpha(data2_matrix, alpha, start)
# 输出结果
cat("=== rho1 = 0.3 的角度结果 ===\n")
print("均值角度:")
print(result1$anglemean[1,1])  # 角度值
print("最小角度:")
print(result1$anglemin[1,1])
print("中位数角度:")
print(result1$anglemedian[1,1])
cat("\n=== rho2 = 0.7 的角度结果 ===\n")
print("均值角度:")
print(result2$anglemean[1,1])  # 角度值
print("最小角度:")
print(result2$anglemin[1,1])
print("中位数角度:")
print(result2$anglemedian[1,1])
# 比较结果
cat("\n=== 角度比较 ===\n")
cat("均值角度比较 (rho1 vs rho2):", result1$anglemean[1,1], "vs", result2$anglemean[1,1], "\n")
cat("rho1角度 > rho2角度:", result1$anglemean[1,1] > result2$anglemean[1,1], "\n")
rho1
rho2
expr_filter <- read.csv("D:\\Academic\\A_Molecular_Interaction_Tree\\cluster_final_results\\cluster_0\\cluster_0_filtered_normalized.csv")
View(expr_filter)
library(parallel)
library(psych)
expr_filter <- read.csv("D:\\Academic\\A_Molecular_Interaction_Tree\\Data\\人体泛组织\\Stomach_results\\process_2_clusters\\cluster_0\\cluster_0_expression_零膨胀.csv")
gene_name <- expr_filter[,1]
rownames(expr_filter) <- expr_filter[,1]
expr_filter <- expr_filter[,-1,drop=F]
gene_name <- rownames(expr_filter)
gene_sd <- apply(expr_filter, 1, sd, na.rm = TRUE)  # 按行计算标准差，忽略NA
sum(gene_sd == 0)  # 输出为0则无问题，否则需要处理
zero_counts <- apply(expr_filter, 1, function(row) sum(row == 0))
save <- which(zero_counts<(dim(expr_filter)[2]*(1/2)))
expr_filter_more <- expr_filter[save,]
zero_counts <- apply(expr_filter, 1, function(row) sum(row == 0))
save <- which(zero_counts<(dim(expr_filter)[2]*(0.2)))
expr_filter_more <- expr_filter[save,]
zero_counts <- apply(expr_filter, 1, function(row) sum(row == 0))
save <- which(zero_counts<(dim(expr_filter)[2]*(0.1)))
expr_filter_more <- expr_filter[save,]
Y_expr <- cor(t(expr_filter_more), method = "kendall")
dim(Y_expr)
cor_matrix <- psych::corr.test(t(expr_filter), method = "kendall",
adjust = "none", ci = FALSE)
set.seed(1234)
library(minet)
# packages <- c("minet")
# dir <- "/mnt/sda/maoshanjun/liusixuan/packages"
# for (pkg in packages) {
#   library(pkg, character.only = TRUE,lib = dir)
# }
mi_network <- minet(
data = t(expr_filter),  # 输入矩阵（行=基因，列=细胞）
estimator = "spearman",
method = "aracne"
)
# 3. 验证矩阵对称性（互信息网络必为对称矩阵）
cat("矩阵对称性检验（应接近0）：", sum(mi_network - t(mi_network)), "\n")
# 4. 二值化：设定阈值（例如取互信息值的上10%作为连接）
threshold <- quantile(mi_network[mi_network > 0], 0.5)  # 排除0值后取上10%分位数
binary_matrix <- ifelse(mi_network > threshold, 1, 0)
diag(binary_matrix) <- 0  # 去除自环
X_sim <- binary_matrix
#########蛋白质互作
library(dplyr)
Y_true <- Y_ppi
library(dplyr)
ppi_filter <- read.csv("D:\\Academic\\A_Molecular_Interaction_Tree\\Empirical_Analysis\\Singal_Cell\\Stomach\\Data\\PPI.csv")
g <- length(gene_name)
Y_ppi <- matrix(0, nrow = g, ncol = g)
rownames(Y_ppi) <- gene_name
colnames(Y_ppi) <- gene_name
for (i in 1:nrow(ppi_filter)) {
element_1 <- ppi_filter$InteractorA[i]
element_2 <- ppi_filter$InteractorB[i]
idx1 <- which(gene_name == element_1)
idx2 <- which(gene_name == element_2)
Y_ppi[idx1, idx2] <- 1
Y_ppi[idx2, idx1] <- 1
}
diag(Y_ppi) <- 0
#########定位
loc_A <- read.csv("D:\\Academic\\A_Molecular_Interaction_Tree\\Empirical_Analysis\\Singal_Cell\\Stomach\\Data\\Loc.csv")
gene_name_df <- data.frame(Gene_name = gene_name)
loc_filter <- left_join(gene_name_df, loc_A, by = c("Gene_name"="Gene.name"))
loc_filter <- read.csv("D:\\Academic\\A_Molecular_Interaction_Tree\\Empirical_Analysis\\Singal_Cell\\NewData\\Stomach\\定位信息_筛.csv")
loc_filter[is.na(loc_filter)] <- 0
rownames(loc_filter) <- loc_filter[,1]
loc_filter <- loc_filter[,-1,drop=F]
loc_filter <- loc_filter[gene_name,]
Y_D <- matrix(0, nrow = nrow(loc_filter), ncol = 3) #这里直接设定的位置有3个
no0_pos <- which(loc_filter != 0, arr.ind = TRUE)   #获取非零元素的位置
Y_D[cbind(no0_pos[, 1], loc_filter[no0_pos])] <- 1
View(loc_filter)
View(loc_A)
gene_name_df <- data.frame(Gene_name = gene_name)
View(gene_name_df)
loc_filter <- left_join(gene_name_df, loc_A, by = c("Gene_name"="Gene.name"))
View(loc_filter)
loc_filter[is.na(loc_filter)] <- 0
rownames(loc_filter) <- loc_filter[,1]
loc_filter <- loc_filter[,-1,drop=F]
Y_D <- matrix(0, nrow = nrow(loc_filter), ncol = 3) #这里直接设定的位置有3个
no0_pos <- which(loc_filter != 0, arr.ind = TRUE)   #获取非零元素的位置
Y_D[cbind(no0_pos[, 1], loc_filter[no0_pos])] <- 1
rownames(Y_D) <- rownames(loc_filter)
dim(Y_expr)
Y_expr <- cor(t(expr_filter), method = "Spearman")
Y_expr <- cor(t(expr_filter), method = "spearman")
rownames(Y_expr) <- gene_name
colnames(Y_expr) <- gene_name
Y_expr[Y_expr == 0] <- 1e-10
# 5. （可选）将对角线设为0（自相关通常无意义）
diag(Y_expr) <- 0
Y_true <- Y_ppi
Y_ppi_8 <- Y_ppi
p <- 0.5
for(i in 1:(g-1)){
for(j in (i+1):g){
if(Y_ppi[i,j]==1){
Y_ppi_8[i,j] <- rbinom(1, 1, p)
Y_ppi_8[j,i] <- Y_ppi_8[i,j]
}
}
}
X_data_sim <- X_sim | Y_ppi_8
save(list=ls(),file="数据_stomach_cluster0_零膨胀.RData")
remove(mi_network)
#########基因表达量
expr_filter <- read.csv("D:\\Academic\\A_Molecular_Interaction_Tree\\Data\\人体泛组织\\Stomach_results\\process_2_clusters\\cluster_0\\cluster_0_expression.csv")
gene_name <- expr_filter[,1]
rownames(expr_filter) <- expr_filter[,1]
expr_filter <- expr_filter[,-1,drop=F]
gene_name <- rownames(expr_filter)
gene_sd <- apply(expr_filter, 1, sd, na.rm = TRUE)  # 按行计算标准差，忽略NA
sum(gene_sd == 0)  # 输出为0则无问题，否则需要处理
# expr_filter_clean <- expr_filter[gene_sd != 0, , drop = FALSE]
# gene_name <- rownames(expr_filter_clean)
zero_counts <- apply(expr_filter, 1, function(row) sum(row == 0))
save <- which(zero_counts<(dim(expr_filter)[2]*(5/6)))
expr_filter_more <- expr_filter[save,]
gene_name <- rownames(expr_filter_more)
save <- which(zero_counts<(dim(expr_filter)[2]*(7/8)))
expr_filter_more <- expr_filter[save,]
gene_name <- rownames(expr_filter_more)
zero_counts <- apply(expr_filter, 1, function(row) sum(row == 0))
save <- which(zero_counts<(dim(expr_filter)[2]*(0.1)))
expr_filter_more <- expr_filter[save,]
gene_name <- rownames(expr_filter_more)
Y_expr <- cor(t(expr_filter_more), method = "spearman")
rownames(Y_expr) <- gene_name
colnames(Y_expr) <- gene_name
diag(Y_expr) <- 0
#########蛋白质互作
library(dplyr)
ppi_filter <- read.csv("D:\\Academic\\A_Molecular_Interaction_Tree\\Empirical_Analysis\\Singal_Cell\\Stomach\\Data\\PPI.csv")
g <- length(gene_name)
Y_ppi <- matrix(0, nrow = g, ncol = g)
rownames(Y_ppi) <- gene_name
colnames(Y_ppi) <- gene_name
for (i in 1:nrow(ppi_filter)) {
element_1 <- ppi_filter$InteractorA[i]
element_2 <- ppi_filter$InteractorB[i]
idx1 <- which(gene_name == element_1)
idx2 <- which(gene_name == element_2)
Y_ppi[idx1, idx2] <- 1
Y_ppi[idx2, idx1] <- 1
}
diag(Y_ppi) <- 0
#########定位
loc_A <- read.csv("D:\\Academic\\A_Molecular_Interaction_Tree\\Empirical_Analysis\\Singal_Cell\\Stomach\\Data\\Loc.csv")
gene_name_df <- data.frame(Gene_name = gene_name)
loc_filter <- left_join(gene_name_df, loc_A, by = c("Gene_name"="Gene.name"))
# loc_filter <- read.csv("D:\\Academic\\A_Molecular_Interaction_Tree\\Empirical_Analysis\\Singal_Cell\\NewData\\Stomach\\定位信息_筛.csv")
loc_filter[is.na(loc_filter)] <- 0
rownames(loc_filter) <- loc_filter[,1]
loc_filter <- loc_filter[,-1,drop=F]
loc_filter <- loc_filter[gene_name,]
Y_D <- matrix(0, nrow = nrow(loc_filter), ncol = 3) #这里直接设定的位置有3个
no0_pos <- which(loc_filter != 0, arr.ind = TRUE)   #获取非零元素的位置
Y_D[cbind(no0_pos[, 1], loc_filter[no0_pos])] <- 1
rownames(Y_D) <- rownames(loc_filter)
#--------------Pre-set Data(Cluster)--------------------------------
set.seed(1234)
library(minet)
# packages <- c("minet")
# dir <- "/mnt/sda/maoshanjun/liusixuan/packages"
# for (pkg in packages) {
#   library(pkg, character.only = TRUE,lib = dir)
# }
mi_network <- minet(
data = t(expr_filter_more),  # 输入矩阵（行=基因，列=细胞）
estimator = "spearman",
method = "aracne"
)
# 3. 验证矩阵对称性（互信息网络必为对称矩阵）
cat("矩阵对称性检验（应接近0）：", sum(mi_network - t(mi_network)), "\n")
# 4. 二值化：设定阈值（例如取互信息值的上10%作为连接）
threshold <- quantile(mi_network[mi_network > 0], 0.5)  # 排除0值后取上10%分位数
binary_matrix <- ifelse(mi_network > threshold, 1, 0)
diag(binary_matrix) <- 0  # 去除自环
X_sim <- binary_matrix
#--------------调整PPI---------------------------------------------
Y_true <- Y_ppi
Y_ppi_8 <- Y_ppi
p <- 0.5
for(i in 1:(g-1)){
for(j in (i+1):g){
if(Y_ppi[i,j]==1){
Y_ppi_8[i,j] <- rbinom(1, 1, p)
Y_ppi_8[j,i] <- Y_ppi_8[i,j]
}
}
}
X_data_sim <- X_sim | Y_ppi_8
#-----------查看真实互作的相关系数情况-------------
Y_true <- Y_ppi
true_inter <- abs(Y_expr[Y_true==1])
false <- sort(abs(Y_expr[Y_true==0]))
false <- false[-c(1:nrow(Y_expr))]
summary(true_inter)
summary(false)
#-------------------检查各种数据里位于同一区域的------------
Y <- Y_ppi
interaction_pairs <- which(Y == 1 & upper.tri(Y), arr.ind = TRUE)
unsame_idx <- c()
samed_pairs <- interaction_pairs
results <- data.frame(gene1 = character(),
gene2 = character(),
gene1_d = I(list()),
gene2_d = I(list()),
same_d = list(),
stringsAsFactors = FALSE)
count_same_region <- 0
for (k in 1:nrow(interaction_pairs)) {
same_domain <- 0
i <- interaction_pairs[k, 1]
j <- interaction_pairs[k, 2]
name_i <- rownames(Y)[i]
name_j <- rownames(Y)[j]
regions_i <- which(Y_D[i, ] == 1)
regions_j <- which(Y_D[j, ] == 1)
if (length(intersect(regions_i, regions_j)) > 0){
count_same_region <- count_same_region + 1
same_domain <- 1
}else{
unsame_idx <- c(unsame_idx,k)
}
results <- rbind(results, data.frame(gene1 =name_i,
gene2 =name_j,
gene1_d = I(list(regions_i)),
gene2_d = I(list(regions_j)),
same_d = same_domain,
stringsAsFactors = FALSE))
}
samed_pairs <- samed_pairs[-unsame_idx,]
Y_true_samed <- matrix(0,nrow(Y_true),ncol(Y_true))
Y_true_samed[samed_pairs] <- 1
Y_true_samed <- pmax(Y_true_samed, t(Y_true_samed)) #对称化
Y_D_samed <- matrix(0, nrow = nrow(Y_D), ncol = 3)
indices <- which(Y_true_samed == 1, arr.ind = TRUE)
selected_rows <- unique(c(indices[,1], indices[,2]))
Y_D_samed[selected_rows, ] <- Y_D[selected_rows, ]
source("D:/Academic/A_Molecular_Interaction_Tree/Code/MCMC_Function_新并行聚类_包含概率_Dopout.R")
source("D:/Academic/A_Molecular_Interaction_Tree/Code/MCMC_Function_新并行聚类_包含概率_Dropout.R")
set.seed(1234)
m1 <- 2 #聚类
m2 <- 3 #重复随机
kappa <- 3; delta <- 2;domain <- 3
num_iter=200     #迭代次数
iter_size=50    #取最后多少次结果进行汇总看平均结果
X_thresP=(0.5);D_thresP=(1/2)
selected_p <- c(0.8,0.001)
time_00 <- Sys.time()
result <- parallel_network_learning(num_iter=num_iter,iter_size=iter_size,
X_thresP=X_thresP,D_thresP=D_thresP,
domain=domain,kappa=kappa,delta=delta,
X_data_t=X_data_sim,X_data_true=Y_ppi_8,
D_t=Y_D,D_true=Y_D,Y_ppi=Y_ppi_8,Y_expr=Y_expr,
m=m1,m_2=m2,cores=10,expr=t(expr_filter_more),selected_p = selected_p)
source("D:/Academic/A_Molecular_Interaction_Tree/Code/MCMC_Function_新并行聚类_包含概率_Dropout.R")
set.seed(1234)
m1 <- 2 #聚类
m2 <- 3 #重复随机
kappa <- 3; delta <- 2;domain <- 3
num_iter=200     #迭代次数
iter_size=50    #取最后多少次结果进行汇总看平均结果
X_thresP=(0.5);D_thresP=(1/2)
selected_p <- c(0.8,0.001)
time_00 <- Sys.time()
result <- parallel_network_learning(num_iter=num_iter,iter_size=iter_size,
X_thresP=X_thresP,D_thresP=D_thresP,
domain=domain,kappa=kappa,delta=delta,
X_data_t=X_data_sim,X_data_true=Y_ppi_8,
D_t=Y_D,D_true=Y_D,Y_ppi=Y_ppi_8,Y_expr=Y_expr,
m=m1,m_2=m2,cores=10,expr=t(expr_filter_more),selected_p = selected_p)
matrix <- X_data_sim
n <- nrow(matrix)
new_matrix <- matrix
# 获取所有边的坐标（只考虑上三角）
edges <- which(upper.tri(matrix) & matrix == 1, arr.ind = TRUE)
total_edges <- nrow(edges)
total_edges
edges
source("D:/Academic/A_Molecular_Interaction_Tree/Code/MCMC_Function_新并行聚类_包含概率_Dropout.R")
set.seed(1234)
m1 <- 2 #聚类
m2 <- 3 #重复随机
kappa <- 3; delta <- 2;domain <- 3
num_iter=200     #迭代次数
iter_size=50    #取最后多少次结果进行汇总看平均结果
X_thresP=(0.5);D_thresP=(1/2)
selected_p <- c(0.8,0.001)
time_00 <- Sys.time()
result <- parallel_network_learning(num_iter=num_iter,iter_size=iter_size,
X_thresP=X_thresP,D_thresP=D_thresP,
domain=domain,kappa=kappa,delta=delta,
X_data_t=X_data_sim,X_data_true=Y_ppi_8,
D_t=Y_D,D_true=Y_D,Y_ppi=Y_ppi_8,Y_expr=Y_expr,
m=m1,m_2=m2,cores=10,expr=t(expr_filter_more),selected_p = selected_p)
X_data_t <- result$X_data_t;D_t <- result$D_t
rownames(X_data_t) <- gene_name
colnames(X_data_t) <- gene_name
rownames(D_t) <- gene_name
time_60 <- Sys.time()
setwd("D:/Academic/Treeangle")
devtools::document()
packageVersion("cli")
install.packages("cli")
packageVersion("cli")
install.packages("cli", INSTALL_opts = c("--no-lock"))
